# Generated from /home/Projects/antlr/Simple.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3,")
        buf.write("\u00c4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\3\2\5\2:\n\2\3\2\3")
        buf.write("\2\3\3\6\3?\n\3\r\3\16\3@\3\4\3\4\3\4\3\5\3\5\3\5\3\5")
        buf.write("\3\5\3\5\3\5\3\6\3\6\7\6O\n\6\f\6\16\6R\13\6\3\6\3\6\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\5\7\\\n\7\3\b\3\b\3\b\5\ba\n\b")
        buf.write("\3\t\3\t\3\n\3\n\3\13\3\13\5\13i\n\13\3\f\3\f\3\r\3\r")
        buf.write("\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\20\3\20\3\20\3\20\3\20\3\20\3\21")
        buf.write("\3\21\3\21\3\21\3\22\3\22\3\22\7\22\u008b\n\22\f\22\16")
        buf.write("\22\u008e\13\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23\5\23")
        buf.write("\u0097\n\23\3\24\3\24\3\24\3\24\7\24\u009d\n\24\f\24\16")
        buf.write("\24\u00a0\13\24\3\25\3\25\3\25\3\25\5\25\u00a6\n\25\3")
        buf.write("\26\3\26\3\26\3\26\7\26\u00ac\n\26\f\26\16\26\u00af\13")
        buf.write("\26\3\27\3\27\3\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32")
        buf.write("\3\33\3\33\3\34\3\34\3\34\3\34\3\34\5\34\u00c2\n\34\3")
        buf.write("\34\2\2\35\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$")
        buf.write("&(*,.\60\62\64\66\2\7\3\2\13\17\3\2()\3\2%&\3\2\20\26")
        buf.write("\3\2\27\34\2\u00ba\29\3\2\2\2\4>\3\2\2\2\6B\3\2\2\2\b")
        buf.write("E\3\2\2\2\nL\3\2\2\2\f[\3\2\2\2\16`\3\2\2\2\20b\3\2\2")
        buf.write("\2\22d\3\2\2\2\24h\3\2\2\2\26j\3\2\2\2\30l\3\2\2\2\32")
        buf.write("p\3\2\2\2\34s\3\2\2\2\36}\3\2\2\2 \u0083\3\2\2\2\"\u0087")
        buf.write("\3\2\2\2$\u008f\3\2\2\2&\u0098\3\2\2\2(\u00a1\3\2\2\2")
        buf.write("*\u00a7\3\2\2\2,\u00b0\3\2\2\2.\u00b4\3\2\2\2\60\u00b6")
        buf.write("\3\2\2\2\62\u00b8\3\2\2\2\64\u00ba\3\2\2\2\66\u00c1\3")
        buf.write("\2\2\28:\5\4\3\298\3\2\2\29:\3\2\2\2:;\3\2\2\2;<\7\2\2")
        buf.write("\3<\3\3\2\2\2=?\5\6\4\2>=\3\2\2\2?@\3\2\2\2@>\3\2\2\2")
        buf.write("@A\3\2\2\2A\5\3\2\2\2BC\5\b\5\2CD\5\n\6\2D\7\3\2\2\2E")
        buf.write("F\7\3\2\2FG\7\4\2\2GH\7\5\2\2HI\5\62\32\2IJ\7\6\2\2JK")
        buf.write("\7\7\2\2K\t\3\2\2\2LP\7\b\2\2MO\5\f\7\2NM\3\2\2\2OR\3")
        buf.write("\2\2\2PN\3\2\2\2PQ\3\2\2\2QS\3\2\2\2RP\3\2\2\2ST\7\t\2")
        buf.write("\2T\13\3\2\2\2U\\\5\20\t\2V\\\5$\23\2W\\\5\36\20\2XY\5")
        buf.write("\16\b\2YZ\7\n\2\2Z\\\3\2\2\2[U\3\2\2\2[V\3\2\2\2[W\3\2")
        buf.write("\2\2[X\3\2\2\2\\\r\3\2\2\2]a\5(\25\2^a\5*\26\2_a\5,\27")
        buf.write("\2`]\3\2\2\2`^\3\2\2\2`_\3\2\2\2a\17\3\2\2\2bc\5\34\17")
        buf.write("\2c\21\3\2\2\2de\t\2\2\2e\23\3\2\2\2fi\5\64\33\2gi\5\66")
        buf.write("\34\2hf\3\2\2\2hg\3\2\2\2i\25\3\2\2\2jk\5(\25\2k\27\3")
        buf.write("\2\2\2lm\5\64\33\2mn\5\22\n\2no\5\66\34\2o\31\3\2\2\2")
        buf.write("pq\t\3\2\2qr\5\64\33\2r\33\3\2\2\2st\7!\2\2tu\7\6\2\2")
        buf.write("uv\5\26\f\2vw\7\n\2\2wx\5\30\r\2xy\7\n\2\2yz\5\32\16\2")
        buf.write("z{\7\7\2\2{|\5\n\6\2|\35\3\2\2\2}~\7\"\2\2~\177\7\6\2")
        buf.write("\2\177\u0080\5\"\22\2\u0080\u0081\7\7\2\2\u0081\u0082")
        buf.write("\5\n\6\2\u0082\37\3\2\2\2\u0083\u0084\5\24\13\2\u0084")
        buf.write("\u0085\5\22\n\2\u0085\u0086\5\24\13\2\u0086!\3\2\2\2\u0087")
        buf.write("\u008c\5 \21\2\u0088\u0089\t\4\2\2\u0089\u008b\5 \21\2")
        buf.write("\u008a\u0088\3\2\2\2\u008b\u008e\3\2\2\2\u008c\u008a\3")
        buf.write("\2\2\2\u008c\u008d\3\2\2\2\u008d#\3\2\2\2\u008e\u008c")
        buf.write("\3\2\2\2\u008f\u0090\7#\2\2\u0090\u0091\7\6\2\2\u0091")
        buf.write("\u0092\5\"\22\2\u0092\u0093\7\7\2\2\u0093\u0096\5\n\6")
        buf.write("\2\u0094\u0095\7$\2\2\u0095\u0097\5\n\6\2\u0096\u0094")
        buf.write("\3\2\2\2\u0096\u0097\3\2\2\2\u0097%\3\2\2\2\u0098\u009e")
        buf.write("\5\24\13\2\u0099\u009a\5.\30\2\u009a\u009b\5\24\13\2\u009b")
        buf.write("\u009d\3\2\2\2\u009c\u0099\3\2\2\2\u009d\u00a0\3\2\2\2")
        buf.write("\u009e\u009c\3\2\2\2\u009e\u009f\3\2\2\2\u009f\'\3\2\2")
        buf.write("\2\u00a0\u009e\3\2\2\2\u00a1\u00a2\5\60\31\2\u00a2\u00a5")
        buf.write("\5\64\33\2\u00a3\u00a4\7\'\2\2\u00a4\u00a6\5\66\34\2\u00a5")
        buf.write("\u00a3\3\2\2\2\u00a5\u00a6\3\2\2\2\u00a6)\3\2\2\2\u00a7")
        buf.write("\u00a8\5\62\32\2\u00a8\u00a9\7\6\2\2\u00a9\u00ad\7\7\2")
        buf.write("\2\u00aa\u00ac\7\n\2\2\u00ab\u00aa\3\2\2\2\u00ac\u00af")
        buf.write("\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae")
        buf.write("+\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b1\5\64\33\2\u00b1")
        buf.write("\u00b2\7\'\2\2\u00b2\u00b3\5&\24\2\u00b3-\3\2\2\2\u00b4")
        buf.write("\u00b5\t\5\2\2\u00b5/\3\2\2\2\u00b6\u00b7\t\6\2\2\u00b7")
        buf.write("\61\3\2\2\2\u00b8\u00b9\7*\2\2\u00b9\63\3\2\2\2\u00ba")
        buf.write("\u00bb\7*\2\2\u00bb\65\3\2\2\2\u00bc\u00c2\7\35\2\2\u00bd")
        buf.write("\u00c2\7\36\2\2\u00be\u00c2\7 \2\2\u00bf\u00c2\7\37\2")
        buf.write("\2\u00c0\u00c2\5*\26\2\u00c1\u00bc\3\2\2\2\u00c1\u00bd")
        buf.write("\3\2\2\2\u00c1\u00be\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c1")
        buf.write("\u00c0\3\2\2\2\u00c2\67\3\2\2\2\169@P[`h\u008c\u0096\u009e")
        buf.write("\u00a5\u00ad\u00c1")
        return buf.getvalue()


class SimpleParser ( Parser ):

    grammarFileName = "Simple.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'public'", "'static'", "'void'", "'('", 
                     "')'", "'{'", "'}'", "';'", "'<'", "'>'", "'<='", "'>='", 
                     "'=='", "'+'", "'-'", "'/'", "'*'", "'&'", "'~'", "'^'", 
                     "'int'", "'byte'", "'string'", "'bool'", "'float'", 
                     "'double'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'for'", "'while'", "'if'", "'else'", 
                     "'&&'", "'||'", "'='", "'++'", "'--'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "BooleanLiteral", 
                      "IntegerLiteral", "StringLiteral", "FloatLiteral", 
                      "FOR", "WHILE", "IF", "ELSE", "AND", "OR", "ASSIGNMENT", 
                      "INC", "DEC", "WORD", "WHITESPACE", "NEWLINE" ]

    RULE_start = 0
    RULE_methodDeclarations = 1
    RULE_methodDeclaration = 2
    RULE_methodHeader = 3
    RULE_methodBody = 4
    RULE_statement = 5
    RULE_embeddedStatement = 6
    RULE_forStatement = 7
    RULE_relationalExpression = 8
    RULE_variable = 9
    RULE_forInitializer = 10
    RULE_forExpression = 11
    RULE_forIterator = 12
    RULE_forLoop = 13
    RULE_whileStatement = 14
    RULE_ifClause = 15
    RULE_ifClauses = 16
    RULE_ifStatement = 17
    RULE_expression = 18
    RULE_localVariableDeclaration = 19
    RULE_methodCall = 20
    RULE_assignment = 21
    RULE_operations = 22
    RULE_variableType = 23
    RULE_methodName = 24
    RULE_variableName = 25
    RULE_variableValue = 26

    ruleNames =  [ "start", "methodDeclarations", "methodDeclaration", "methodHeader", 
                   "methodBody", "statement", "embeddedStatement", "forStatement", 
                   "relationalExpression", "variable", "forInitializer", 
                   "forExpression", "forIterator", "forLoop", "whileStatement", 
                   "ifClause", "ifClauses", "ifStatement", "expression", 
                   "localVariableDeclaration", "methodCall", "assignment", 
                   "operations", "variableType", "methodName", "variableName", 
                   "variableValue" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    BooleanLiteral=27
    IntegerLiteral=28
    StringLiteral=29
    FloatLiteral=30
    FOR=31
    WHILE=32
    IF=33
    ELSE=34
    AND=35
    OR=36
    ASSIGNMENT=37
    INC=38
    DEC=39
    WORD=40
    WHITESPACE=41
    NEWLINE=42

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SimpleParser.EOF, 0)

        def methodDeclarations(self):
            return self.getTypedRuleContext(SimpleParser.MethodDeclarationsContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStart" ):
                return visitor.visitStart(self)
            else:
                return visitor.visitChildren(self)




    def start(self):

        localctx = SimpleParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SimpleParser.T__0:
                self.state = 54
                self.methodDeclarations()


            self.state = 57
            self.match(SimpleParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDeclarationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.MethodDeclarationContext)
            else:
                return self.getTypedRuleContext(SimpleParser.MethodDeclarationContext,i)


        def getRuleIndex(self):
            return SimpleParser.RULE_methodDeclarations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDeclarations" ):
                listener.enterMethodDeclarations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDeclarations" ):
                listener.exitMethodDeclarations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodDeclarations" ):
                return visitor.visitMethodDeclarations(self)
            else:
                return visitor.visitChildren(self)




    def methodDeclarations(self):

        localctx = SimpleParser.MethodDeclarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_methodDeclarations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 59
                self.methodDeclaration()
                self.state = 62 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SimpleParser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodHeader(self):
            return self.getTypedRuleContext(SimpleParser.MethodHeaderContext,0)


        def methodBody(self):
            return self.getTypedRuleContext(SimpleParser.MethodBodyContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_methodDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDeclaration" ):
                listener.enterMethodDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDeclaration" ):
                listener.exitMethodDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodDeclaration" ):
                return visitor.visitMethodDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def methodDeclaration(self):

        localctx = SimpleParser.MethodDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_methodDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.methodHeader()
            self.state = 65
            self.methodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodName(self):
            return self.getTypedRuleContext(SimpleParser.MethodNameContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_methodHeader

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodHeader" ):
                listener.enterMethodHeader(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodHeader" ):
                listener.exitMethodHeader(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodHeader" ):
                return visitor.visitMethodHeader(self)
            else:
                return visitor.visitChildren(self)




    def methodHeader(self):

        localctx = SimpleParser.MethodHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_methodHeader)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.match(SimpleParser.T__0)
            self.state = 68
            self.match(SimpleParser.T__1)
            self.state = 69
            self.match(SimpleParser.T__2)
            self.state = 70
            self.methodName()
            self.state = 71
            self.match(SimpleParser.T__3)
            self.state = 72
            self.match(SimpleParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.StatementContext)
            else:
                return self.getTypedRuleContext(SimpleParser.StatementContext,i)


        def getRuleIndex(self):
            return SimpleParser.RULE_methodBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodBody" ):
                listener.enterMethodBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodBody" ):
                listener.exitMethodBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodBody" ):
                return visitor.visitMethodBody(self)
            else:
                return visitor.visitChildren(self)




    def methodBody(self):

        localctx = SimpleParser.MethodBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_methodBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(SimpleParser.T__5)
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimpleParser.T__20) | (1 << SimpleParser.T__21) | (1 << SimpleParser.T__22) | (1 << SimpleParser.T__23) | (1 << SimpleParser.T__24) | (1 << SimpleParser.T__25) | (1 << SimpleParser.FOR) | (1 << SimpleParser.WHILE) | (1 << SimpleParser.IF) | (1 << SimpleParser.WORD))) != 0):
                self.state = 75
                self.statement()
                self.state = 80
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 81
            self.match(SimpleParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forStatement(self):
            return self.getTypedRuleContext(SimpleParser.ForStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(SimpleParser.IfStatementContext,0)


        def whileStatement(self):
            return self.getTypedRuleContext(SimpleParser.WhileStatementContext,0)


        def embeddedStatement(self):
            return self.getTypedRuleContext(SimpleParser.EmbeddedStatementContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = SimpleParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_statement)
        try:
            self.state = 89
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SimpleParser.FOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 83
                self.forStatement()
                pass
            elif token in [SimpleParser.IF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                self.ifStatement()
                pass
            elif token in [SimpleParser.WHILE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 85
                self.whileStatement()
                pass
            elif token in [SimpleParser.T__20, SimpleParser.T__21, SimpleParser.T__22, SimpleParser.T__23, SimpleParser.T__24, SimpleParser.T__25, SimpleParser.WORD]:
                self.enterOuterAlt(localctx, 4)
                self.state = 86
                self.embeddedStatement()
                self.state = 87
                self.match(SimpleParser.T__7)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmbeddedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(SimpleParser.LocalVariableDeclarationContext,0)


        def methodCall(self):
            return self.getTypedRuleContext(SimpleParser.MethodCallContext,0)


        def assignment(self):
            return self.getTypedRuleContext(SimpleParser.AssignmentContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_embeddedStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmbeddedStatement" ):
                listener.enterEmbeddedStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmbeddedStatement" ):
                listener.exitEmbeddedStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmbeddedStatement" ):
                return visitor.visitEmbeddedStatement(self)
            else:
                return visitor.visitChildren(self)




    def embeddedStatement(self):

        localctx = SimpleParser.EmbeddedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_embeddedStatement)
        try:
            self.state = 94
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 91
                self.localVariableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 92
                self.methodCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 93
                self.assignment()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forLoop(self):
            return self.getTypedRuleContext(SimpleParser.ForLoopContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_forStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForStatement" ):
                listener.enterForStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForStatement" ):
                listener.exitForStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStatement" ):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)




    def forStatement(self):

        localctx = SimpleParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_forStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.forLoop()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SimpleParser.RULE_relationalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationalExpression" ):
                listener.enterRelationalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationalExpression" ):
                listener.exitRelationalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationalExpression" ):
                return visitor.visitRelationalExpression(self)
            else:
                return visitor.visitChildren(self)




    def relationalExpression(self):

        localctx = SimpleParser.RelationalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_relationalExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimpleParser.T__8) | (1 << SimpleParser.T__9) | (1 << SimpleParser.T__10) | (1 << SimpleParser.T__11) | (1 << SimpleParser.T__12))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(SimpleParser.VariableNameContext,0)


        def variableValue(self):
            return self.getTypedRuleContext(SimpleParser.VariableValueContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = SimpleParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 100
                self.variableName()
                pass

            elif la_ == 2:
                self.state = 101
                self.variableValue()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(SimpleParser.LocalVariableDeclarationContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_forInitializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInitializer" ):
                listener.enterForInitializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInitializer" ):
                listener.exitForInitializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForInitializer" ):
                return visitor.visitForInitializer(self)
            else:
                return visitor.visitChildren(self)




    def forInitializer(self):

        localctx = SimpleParser.ForInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_forInitializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.localVariableDeclaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(SimpleParser.VariableNameContext,0)


        def relationalExpression(self):
            return self.getTypedRuleContext(SimpleParser.RelationalExpressionContext,0)


        def variableValue(self):
            return self.getTypedRuleContext(SimpleParser.VariableValueContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_forExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForExpression" ):
                listener.enterForExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForExpression" ):
                listener.exitForExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForExpression" ):
                return visitor.visitForExpression(self)
            else:
                return visitor.visitChildren(self)




    def forExpression(self):

        localctx = SimpleParser.ForExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_forExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.variableName()
            self.state = 107
            self.relationalExpression()
            self.state = 108
            self.variableValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForIteratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(SimpleParser.VariableNameContext,0)


        def INC(self):
            return self.getToken(SimpleParser.INC, 0)

        def DEC(self):
            return self.getToken(SimpleParser.DEC, 0)

        def getRuleIndex(self):
            return SimpleParser.RULE_forIterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForIterator" ):
                listener.enterForIterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForIterator" ):
                listener.exitForIterator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForIterator" ):
                return visitor.visitForIterator(self)
            else:
                return visitor.visitChildren(self)




    def forIterator(self):

        localctx = SimpleParser.ForIteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_forIterator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            _la = self._input.LA(1)
            if not(_la==SimpleParser.INC or _la==SimpleParser.DEC):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 111
            self.variableName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(SimpleParser.FOR, 0)

        def forInitializer(self):
            return self.getTypedRuleContext(SimpleParser.ForInitializerContext,0)


        def forExpression(self):
            return self.getTypedRuleContext(SimpleParser.ForExpressionContext,0)


        def forIterator(self):
            return self.getTypedRuleContext(SimpleParser.ForIteratorContext,0)


        def methodBody(self):
            return self.getTypedRuleContext(SimpleParser.MethodBodyContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForLoop" ):
                return visitor.visitForLoop(self)
            else:
                return visitor.visitChildren(self)




    def forLoop(self):

        localctx = SimpleParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_forLoop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(SimpleParser.FOR)
            self.state = 114
            self.match(SimpleParser.T__3)
            self.state = 115
            self.forInitializer()
            self.state = 116
            self.match(SimpleParser.T__7)
            self.state = 117
            self.forExpression()
            self.state = 118
            self.match(SimpleParser.T__7)
            self.state = 119
            self.forIterator()
            self.state = 120
            self.match(SimpleParser.T__4)
            self.state = 121
            self.methodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(SimpleParser.WHILE, 0)

        def ifClauses(self):
            return self.getTypedRuleContext(SimpleParser.IfClausesContext,0)


        def methodBody(self):
            return self.getTypedRuleContext(SimpleParser.MethodBodyContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_whileStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileStatement" ):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)




    def whileStatement(self):

        localctx = SimpleParser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_whileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(SimpleParser.WHILE)
            self.state = 124
            self.match(SimpleParser.T__3)
            self.state = 125
            self.ifClauses()
            self.state = 126
            self.match(SimpleParser.T__4)
            self.state = 127
            self.methodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.VariableContext)
            else:
                return self.getTypedRuleContext(SimpleParser.VariableContext,i)


        def relationalExpression(self):
            return self.getTypedRuleContext(SimpleParser.RelationalExpressionContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_ifClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfClause" ):
                listener.enterIfClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfClause" ):
                listener.exitIfClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfClause" ):
                return visitor.visitIfClause(self)
            else:
                return visitor.visitChildren(self)




    def ifClause(self):

        localctx = SimpleParser.IfClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_ifClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.variable()
            self.state = 130
            self.relationalExpression()
            self.state = 131
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.IfClauseContext)
            else:
                return self.getTypedRuleContext(SimpleParser.IfClauseContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(SimpleParser.AND)
            else:
                return self.getToken(SimpleParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(SimpleParser.OR)
            else:
                return self.getToken(SimpleParser.OR, i)

        def getRuleIndex(self):
            return SimpleParser.RULE_ifClauses

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfClauses" ):
                listener.enterIfClauses(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfClauses" ):
                listener.exitIfClauses(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfClauses" ):
                return visitor.visitIfClauses(self)
            else:
                return visitor.visitChildren(self)




    def ifClauses(self):

        localctx = SimpleParser.IfClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_ifClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.ifClause()
            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SimpleParser.AND or _la==SimpleParser.OR:
                self.state = 134
                _la = self._input.LA(1)
                if not(_la==SimpleParser.AND or _la==SimpleParser.OR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 135
                self.ifClause()
                self.state = 140
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(SimpleParser.IF, 0)

        def ifClauses(self):
            return self.getTypedRuleContext(SimpleParser.IfClausesContext,0)


        def methodBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.MethodBodyContext)
            else:
                return self.getTypedRuleContext(SimpleParser.MethodBodyContext,i)


        def ELSE(self):
            return self.getToken(SimpleParser.ELSE, 0)

        def getRuleIndex(self):
            return SimpleParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = SimpleParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ifStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(SimpleParser.IF)
            self.state = 142
            self.match(SimpleParser.T__3)
            self.state = 143
            self.ifClauses()
            self.state = 144
            self.match(SimpleParser.T__4)
            self.state = 145
            self.methodBody()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SimpleParser.ELSE:
                self.state = 146
                self.match(SimpleParser.ELSE)
                self.state = 147
                self.methodBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.VariableContext)
            else:
                return self.getTypedRuleContext(SimpleParser.VariableContext,i)


        def operations(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SimpleParser.OperationsContext)
            else:
                return self.getTypedRuleContext(SimpleParser.OperationsContext,i)


        def getRuleIndex(self):
            return SimpleParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = SimpleParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.variable()
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimpleParser.T__13) | (1 << SimpleParser.T__14) | (1 << SimpleParser.T__15) | (1 << SimpleParser.T__16) | (1 << SimpleParser.T__17) | (1 << SimpleParser.T__18) | (1 << SimpleParser.T__19))) != 0):
                self.state = 151
                self.operations()
                self.state = 152
                self.variable()
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocalVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableType(self):
            return self.getTypedRuleContext(SimpleParser.VariableTypeContext,0)


        def variableName(self):
            return self.getTypedRuleContext(SimpleParser.VariableNameContext,0)


        def ASSIGNMENT(self):
            return self.getToken(SimpleParser.ASSIGNMENT, 0)

        def variableValue(self):
            return self.getTypedRuleContext(SimpleParser.VariableValueContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_localVariableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocalVariableDeclaration" ):
                listener.enterLocalVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocalVariableDeclaration" ):
                listener.exitLocalVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocalVariableDeclaration" ):
                return visitor.visitLocalVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def localVariableDeclaration(self):

        localctx = SimpleParser.LocalVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_localVariableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self.variableType()
            self.state = 160
            self.variableName()
            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SimpleParser.ASSIGNMENT:
                self.state = 161
                self.match(SimpleParser.ASSIGNMENT)
                self.state = 162
                self.variableValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodName(self):
            return self.getTypedRuleContext(SimpleParser.MethodNameContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_methodCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodCall" ):
                listener.enterMethodCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodCall" ):
                listener.exitMethodCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodCall" ):
                return visitor.visitMethodCall(self)
            else:
                return visitor.visitChildren(self)




    def methodCall(self):

        localctx = SimpleParser.MethodCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_methodCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.methodName()
            self.state = 166
            self.match(SimpleParser.T__3)
            self.state = 167
            self.match(SimpleParser.T__4)
            self.state = 171
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 168
                    self.match(SimpleParser.T__7) 
                self.state = 173
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableName(self):
            return self.getTypedRuleContext(SimpleParser.VariableNameContext,0)


        def ASSIGNMENT(self):
            return self.getToken(SimpleParser.ASSIGNMENT, 0)

        def expression(self):
            return self.getTypedRuleContext(SimpleParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SimpleParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = SimpleParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.variableName()
            self.state = 175
            self.match(SimpleParser.ASSIGNMENT)
            self.state = 176
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SimpleParser.RULE_operations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperations" ):
                listener.enterOperations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperations" ):
                listener.exitOperations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperations" ):
                return visitor.visitOperations(self)
            else:
                return visitor.visitChildren(self)




    def operations(self):

        localctx = SimpleParser.OperationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_operations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimpleParser.T__13) | (1 << SimpleParser.T__14) | (1 << SimpleParser.T__15) | (1 << SimpleParser.T__16) | (1 << SimpleParser.T__17) | (1 << SimpleParser.T__18) | (1 << SimpleParser.T__19))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SimpleParser.RULE_variableType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableType" ):
                listener.enterVariableType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableType" ):
                listener.exitVariableType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableType" ):
                return visitor.visitVariableType(self)
            else:
                return visitor.visitChildren(self)




    def variableType(self):

        localctx = SimpleParser.VariableTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_variableType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SimpleParser.T__20) | (1 << SimpleParser.T__21) | (1 << SimpleParser.T__22) | (1 << SimpleParser.T__23) | (1 << SimpleParser.T__24) | (1 << SimpleParser.T__25))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WORD(self):
            return self.getToken(SimpleParser.WORD, 0)

        def getRuleIndex(self):
            return SimpleParser.RULE_methodName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodName" ):
                listener.enterMethodName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodName" ):
                listener.exitMethodName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodName" ):
                return visitor.visitMethodName(self)
            else:
                return visitor.visitChildren(self)




    def methodName(self):

        localctx = SimpleParser.MethodNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_methodName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(SimpleParser.WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WORD(self):
            return self.getToken(SimpleParser.WORD, 0)

        def getRuleIndex(self):
            return SimpleParser.RULE_variableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableName" ):
                listener.enterVariableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableName" ):
                listener.exitVariableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableName" ):
                return visitor.visitVariableName(self)
            else:
                return visitor.visitChildren(self)




    def variableName(self):

        localctx = SimpleParser.VariableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_variableName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.match(SimpleParser.WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SimpleParser.RULE_variableValue

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PBooleanLiteralContext(VariableValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SimpleParser.VariableValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BooleanLiteral(self):
            return self.getToken(SimpleParser.BooleanLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPBooleanLiteral" ):
                listener.enterPBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPBooleanLiteral" ):
                listener.exitPBooleanLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPBooleanLiteral" ):
                return visitor.visitPBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)


    class PFloatLiteralContext(VariableValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SimpleParser.VariableValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FloatLiteral(self):
            return self.getToken(SimpleParser.FloatLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPFloatLiteral" ):
                listener.enterPFloatLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPFloatLiteral" ):
                listener.exitPFloatLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPFloatLiteral" ):
                return visitor.visitPFloatLiteral(self)
            else:
                return visitor.visitChildren(self)


    class PStringLiteralContext(VariableValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SimpleParser.VariableValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def StringLiteral(self):
            return self.getToken(SimpleParser.StringLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPStringLiteral" ):
                listener.enterPStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPStringLiteral" ):
                listener.exitPStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPStringLiteral" ):
                return visitor.visitPStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class MethodCall_Context(VariableValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SimpleParser.VariableValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def methodCall(self):
            return self.getTypedRuleContext(SimpleParser.MethodCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodCall_" ):
                listener.enterMethodCall_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodCall_" ):
                listener.exitMethodCall_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMethodCall_" ):
                return visitor.visitMethodCall_(self)
            else:
                return visitor.visitChildren(self)


    class PIntegerLiteralContext(VariableValueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SimpleParser.VariableValueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IntegerLiteral(self):
            return self.getToken(SimpleParser.IntegerLiteral, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPIntegerLiteral" ):
                listener.enterPIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPIntegerLiteral" ):
                listener.exitPIntegerLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPIntegerLiteral" ):
                return visitor.visitPIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)



    def variableValue(self):

        localctx = SimpleParser.VariableValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_variableValue)
        try:
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SimpleParser.BooleanLiteral]:
                localctx = SimpleParser.PBooleanLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                self.match(SimpleParser.BooleanLiteral)
                pass
            elif token in [SimpleParser.IntegerLiteral]:
                localctx = SimpleParser.PIntegerLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                self.match(SimpleParser.IntegerLiteral)
                pass
            elif token in [SimpleParser.FloatLiteral]:
                localctx = SimpleParser.PFloatLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 188
                self.match(SimpleParser.FloatLiteral)
                pass
            elif token in [SimpleParser.StringLiteral]:
                localctx = SimpleParser.PStringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 189
                self.match(SimpleParser.StringLiteral)
                pass
            elif token in [SimpleParser.WORD]:
                localctx = SimpleParser.MethodCall_Context(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 190
                self.methodCall()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





